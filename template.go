package main

import (
	"fmt"
	"text/template"
	"time"
)

type exportData struct {
	PackageName  string
	FunctionName string
	UseReaders   bool

	Data       payload
	Compressed payload
	Debug      bool

	ParseTime   time.Time
	Compression int
	PctSavings  float64
}

var exportTemplate = template.Must(template.New("full").Parse(`// Code generated by go-binary (github.com/jimmysawczuk/go-binary); DO NOT EDIT.
// Generated {{ .ParseTime.Format "2006-01-02T15:04:05-0700" }}; compression = {{ .Compression }}, {{ printf "%0.1f%% saved" .PctSavings }}
package {{ .PackageName }}

import(
	"compress/gzip"
	"bytes"
	{{ if .UseReaders -}}
	"io"
	{{- else -}}
	"io/ioutil"
	{{- end }}
)

// {{ .FunctionName }} returns data generated by go-binary. It can return an error
// if the decompression fails.
func {{ .FunctionName }}() {{ if .UseReaders }}(io.Reader, error){{ else }}([]byte, error){{ end }} {
	{{- if .UseReaders }}
	return gzip.NewReader(bytes.NewReader([]byte{{ .Compressed.FormatForCode }}))
	{{- else -}}
	gz, err := gzip.NewReader(bytes.NewReader([]byte{{ .Compressed.FormatForCode }}))
	if err != nil {
		return []byte{}, err
	}
	return ioutil.ReadAll(gz)
	{{ end -}}
}

{{ if .Debug -}}
// RAW DATA RETURNED BY {{ .FunctionName }}:
/*
{{ .Data.SafeString }}
*/
{{- end }}
`)).Funcs(map[string]interface{}{
	"formatForCode": formatForCode,
})

func formatForCode(in []byte) string {
	str := `{`

	i := 0
	for _, v := range in {
		if i%12 == 0 {
			str = str + newline
			i = 0
		}

		str = str + fmt.Sprintf("0x%02x,", v)
		i++
	}

	str = str + `}`

	return str
}
